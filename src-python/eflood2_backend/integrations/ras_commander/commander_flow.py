#!/usr/bin/env python3
"""
üåä RAS Commander Flow Analysis Module
====================================

M√≥dulo especializado para el an√°lisis de flujo y condiciones de frontera HEC-RAS usando RAS Commander.
Proporciona funcionalidades avanzadas para an√°lisis hidr√°ulico y gesti√≥n de condiciones de frontera.

Funcionalidades principales:
- An√°lisis de condiciones de frontera
- Procesamiento de datos de flujo
- An√°lisis fluvial-pluvial
- Gesti√≥n de hidrogramas
- An√°lisis de precipitaci√≥n e infiltraci√≥n

Autor: eFlood2 Technologies
Versi√≥n: 0.1.0
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IMPORTS Y CONFIGURACI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import json
import logging
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import geopandas as gpd
import numpy as np
import pandas as pd

# RAS Commander imports
try:
    from ras_commander import HdfBndry, HdfFluvialPluvial, HdfMesh, HdfPlan, RasUnsteady

    RAS_COMMANDER_AVAILABLE = True
except ImportError:
    RAS_COMMANDER_AVAILABLE = False

# Imports locales
from .commander_utils import (
    convert_numpy_types,
    create_result_dict,
    handle_ras_exceptions,
    logger,
    ras_commander_required,
    safe_json_serialize,
    validate_hdf_file,
)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CLASE PRINCIPAL PARA AN√ÅLISIS DE FLUJO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


class CommanderFlowAnalyzer:
    """
    üåä Analizador de flujo HEC-RAS usando RAS Commander.

    Proporciona funcionalidades avanzadas para el an√°lisis de flujo,
    condiciones de frontera y an√°lisis hidr√°ulico en modelos HEC-RAS.
    """

    def __init__(self, hdf_file_path: str):
        """
        Inicializa el analizador de flujo.

        Args:
            hdf_file_path: Ruta al archivo HDF de HEC-RAS
        """
        self.hdf_file_path = hdf_file_path
        self.validation_result = validate_hdf_file(hdf_file_path)

        if not self.validation_result["success"]:
            logger.error(
                f"Error validando archivo HDF: {self.validation_result['error']}"
            )

    @ras_commander_required
    @handle_ras_exceptions
    def get_boundary_conditions_analysis(self) -> Dict[str, Any]:
        """
        Realiza an√°lisis completo de condiciones de frontera.

        Returns:
            Dict con an√°lisis detallado de condiciones de frontera
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            boundary_analysis = {
                "flow_boundaries": self._analyze_flow_boundaries(),
                "stage_boundaries": self._analyze_stage_boundaries(),
                "precipitation": self._analyze_precipitation(),
                "infiltration": self._analyze_infiltration(),
                "breaklines": self._analyze_boundary_breaklines(),
            }

            # Contar total de elementos de frontera
            total_boundaries = sum(
                analysis.get("count", 0)
                for analysis in boundary_analysis.values()
                if isinstance(analysis, dict)
            )

            logger.info(
                f"An√°lisis de condiciones de frontera completado: {total_boundaries} elementos"
            )

            return create_result_dict(
                success=True,
                data={
                    "total_boundary_elements": total_boundaries,
                    "analysis_timestamp": datetime.now().isoformat(),
                    "boundaries_by_type": boundary_analysis,
                },
                message=f"An√°lisis de {total_boundaries} condiciones de frontera completado",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def get_fluvial_pluvial_analysis(self, delta_t: int = 12) -> Dict[str, Any]:
        """
        Realiza an√°lisis fluvial-pluvial usando RAS Commander.

        Args:
            delta_t: Umbral de tiempo en horas para el an√°lisis

        Returns:
            Dict con an√°lisis fluvial-pluvial
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # Realizar an√°lisis fluvial-pluvial usando RAS Commander
            boundary_data = HdfFluvialPluvial.calculate_fluvial_pluvial_boundary(
                self.hdf_file_path, delta_t=delta_t
            )

            if boundary_data is None or boundary_data.empty:
                return create_result_dict(
                    success=False,
                    error=f"No se pudieron calcular l√≠mites fluvial-pluvial con delta_t={delta_t}h",
                )

            # An√°lisis de los datos de frontera
            analysis = {
                "delta_t_hours": delta_t,
                "boundary_elements": len(boundary_data),
                "columns": list(boundary_data.columns),
                "has_geometry": hasattr(boundary_data, "geometry"),
                "statistics": {},
                "spatial_info": {},
            }

            # Estad√≠sticas de columnas num√©ricas
            numeric_cols = boundary_data.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats_dict = boundary_data[numeric_cols].describe().to_dict()
                analysis["statistics"] = convert_numpy_types(stats_dict)

            # Informaci√≥n espacial si hay geometr√≠a
            if (
                hasattr(boundary_data, "geometry")
                and boundary_data.geometry is not None
            ):
                bounds = boundary_data.total_bounds
                analysis["spatial_info"] = {
                    "bounds": {
                        "minx": float(bounds[0]),
                        "miny": float(bounds[1]),
                        "maxx": float(bounds[2]),
                        "maxy": float(bounds[3]),
                    },
                    "crs": str(boundary_data.crs) if boundary_data.crs else None,
                }

            logger.info(
                f"An√°lisis fluvial-pluvial completado: {len(boundary_data)} elementos"
            )

            return create_result_dict(
                success=True,
                data=analysis,
                message=f"An√°lisis fluvial-pluvial completado con {len(boundary_data)} elementos",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def get_hydrograph_analysis(self) -> Dict[str, Any]:
        """
        Realiza an√°lisis de hidrogramas del modelo.

        Returns:
            Dict con an√°lisis de hidrogramas
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # An√°lisis de hidrogramas usando datos de frontera
            hydrograph_analysis = {
                "flow_hydrographs": self._analyze_flow_hydrographs(),
                "stage_hydrographs": self._analyze_stage_hydrographs(),
                "precipitation_hyetographs": self._analyze_precipitation_hyetographs(),
            }

            # Contar hidrogramas procesados
            total_hydrographs = sum(
                analysis.get("count", 0)
                for analysis in hydrograph_analysis.values()
                if isinstance(analysis, dict)
            )

            logger.info(
                f"An√°lisis de hidrogramas completado: {total_hydrographs} elementos"
            )

            return create_result_dict(
                success=True,
                data={
                    "total_hydrographs": total_hydrographs,
                    "analysis_timestamp": datetime.now().isoformat(),
                    "hydrographs_by_type": hydrograph_analysis,
                },
                message=f"An√°lisis de {total_hydrographs} hidrogramas completado",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def export_flow_data(self, output_directory: str) -> Dict[str, Any]:
        """
        Exporta datos de flujo a archivos.

        Args:
            output_directory: Directorio de salida

        Returns:
            Dict con resultado de la exportaci√≥n
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            os.makedirs(output_directory, exist_ok=True)
            exported_files = []

            # Exportar an√°lisis de condiciones de frontera
            boundary_analysis = self.get_boundary_conditions_analysis()
            if boundary_analysis["success"]:
                boundary_file = os.path.join(
                    output_directory, "boundary_conditions_analysis.json"
                )
                with open(boundary_file, "w", encoding="utf-8") as f:
                    json.dump(
                        boundary_analysis["data"], f, indent=2, ensure_ascii=False
                    )
                exported_files.append(boundary_file)

            # Exportar an√°lisis fluvial-pluvial
            fluvial_pluvial = self.get_fluvial_pluvial_analysis()
            if fluvial_pluvial["success"]:
                fp_file = os.path.join(
                    output_directory, "fluvial_pluvial_analysis.json"
                )
                with open(fp_file, "w", encoding="utf-8") as f:
                    json.dump(fluvial_pluvial["data"], f, indent=2, ensure_ascii=False)
                exported_files.append(fp_file)

            # Exportar an√°lisis de hidrogramas
            hydrograph_analysis = self.get_hydrograph_analysis()
            if hydrograph_analysis["success"]:
                hydro_file = os.path.join(output_directory, "hydrograph_analysis.json")
                with open(hydro_file, "w", encoding="utf-8") as f:
                    json.dump(
                        hydrograph_analysis["data"], f, indent=2, ensure_ascii=False
                    )
                exported_files.append(hydro_file)

            logger.info(f"Datos de flujo exportados: {len(exported_files)} archivos")

            return create_result_dict(
                success=True,
                data={
                    "output_directory": output_directory,
                    "exported_files": exported_files,
                    "total_files": len(exported_files),
                },
                message=f"Datos de flujo exportados exitosamente: {len(exported_files)} archivos",
            )

        except Exception as e:
            raise e

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # M√âTODOS PRIVADOS DE AN√ÅLISIS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _analyze_flow_boundaries(self) -> Dict[str, Any]:
        """Analiza condiciones de frontera de flujo."""
        try:
            # Obtener condiciones de frontera de flujo usando RAS Commander
            flow_boundaries = HdfBndry.get_flow_boundaries(self.hdf_file_path)

            if flow_boundaries is None or flow_boundaries.empty:
                return {
                    "count": 0,
                    "note": "No se encontraron condiciones de frontera de flujo",
                }

            analysis = {
                "count": len(flow_boundaries),
                "columns": list(flow_boundaries.columns),
                "has_geometry": hasattr(flow_boundaries, "geometry"),
            }

            # Estad√≠sticas si hay datos num√©ricos
            numeric_cols = flow_boundaries.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats = flow_boundaries[numeric_cols].describe().to_dict()
                analysis["statistics"] = convert_numpy_types(stats)

            return analysis

        except Exception as e:
            return {"error": f"Error analizando condiciones de flujo: {str(e)}"}

    def _analyze_stage_boundaries(self) -> Dict[str, Any]:
        """Analiza condiciones de frontera de nivel."""
        try:
            # Obtener condiciones de frontera de nivel usando RAS Commander
            stage_boundaries = HdfBndry.get_stage_boundaries(self.hdf_file_path)

            if stage_boundaries is None or stage_boundaries.empty:
                return {
                    "count": 0,
                    "note": "No se encontraron condiciones de frontera de nivel",
                }

            analysis = {
                "count": len(stage_boundaries),
                "columns": list(stage_boundaries.columns),
                "has_geometry": hasattr(stage_boundaries, "geometry"),
            }

            # Estad√≠sticas si hay datos num√©ricos
            numeric_cols = stage_boundaries.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats = stage_boundaries[numeric_cols].describe().to_dict()
                analysis["statistics"] = convert_numpy_types(stats)

            return analysis

        except Exception as e:
            return {"error": f"Error analizando condiciones de nivel: {str(e)}"}

    def _analyze_precipitation(self) -> Dict[str, Any]:
        """Analiza datos de precipitaci√≥n."""
        try:
            # Obtener datos de precipitaci√≥n usando RAS Commander
            precipitation_data = HdfBndry.get_precipitation(self.hdf_file_path)

            if precipitation_data is None or precipitation_data.empty:
                return {"count": 0, "note": "No se encontraron datos de precipitaci√≥n"}

            analysis = {
                "count": len(precipitation_data),
                "columns": list(precipitation_data.columns),
                "has_geometry": hasattr(precipitation_data, "geometry"),
            }

            # Estad√≠sticas si hay datos num√©ricos
            numeric_cols = precipitation_data.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats = precipitation_data[numeric_cols].describe().to_dict()
                analysis["statistics"] = convert_numpy_types(stats)

            return analysis

        except Exception as e:
            return {"error": f"Error analizando precipitaci√≥n: {str(e)}"}

    def _analyze_infiltration(self) -> Dict[str, Any]:
        """Analiza datos de infiltraci√≥n."""
        try:
            # Obtener datos de infiltraci√≥n usando RAS Commander
            infiltration_data = HdfBndry.get_infiltration(self.hdf_file_path)

            if infiltration_data is None or infiltration_data.empty:
                return {"count": 0, "note": "No se encontraron datos de infiltraci√≥n"}

            analysis = {
                "count": len(infiltration_data),
                "columns": list(infiltration_data.columns),
                "has_geometry": hasattr(infiltration_data, "geometry"),
            }

            # Estad√≠sticas si hay datos num√©ricos
            numeric_cols = infiltration_data.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats = infiltration_data[numeric_cols].describe().to_dict()
                analysis["statistics"] = convert_numpy_types(stats)

            return analysis

        except Exception as e:
            return {"error": f"Error analizando infiltraci√≥n: {str(e)}"}

    def _analyze_boundary_breaklines(self) -> Dict[str, Any]:
        """Analiza breaklines relacionadas con condiciones de frontera."""
        try:
            # Obtener breaklines usando RAS Commander
            breaklines = HdfBndry.get_breaklines(self.hdf_file_path)

            if breaklines is None or breaklines.empty:
                return {"count": 0, "note": "No se encontraron breaklines"}

            return {
                "count": len(breaklines),
                "columns": list(breaklines.columns),
                "has_geometry": hasattr(breaklines, "geometry"),
            }

        except Exception as e:
            return {"error": f"Error analizando breaklines: {str(e)}"}

    def _analyze_flow_hydrographs(self) -> Dict[str, Any]:
        """Analiza hidrogramas de flujo."""
        try:
            return {
                "count": 0,
                "note": "An√°lisis de hidrogramas de flujo pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando hidrogramas de flujo: {str(e)}"}

    def _analyze_stage_hydrographs(self) -> Dict[str, Any]:
        """Analiza hidrogramas de nivel."""
        try:
            return {
                "count": 0,
                "note": "An√°lisis de hidrogramas de nivel pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando hidrogramas de nivel: {str(e)}"}

    def _analyze_precipitation_hyetographs(self) -> Dict[str, Any]:
        """Analiza hietogramas de precipitaci√≥n."""
        try:
            return {
                "count": 0,
                "note": "An√°lisis de hietogramas pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando hietogramas: {str(e)}"}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FUNCIONES DE UTILIDAD PARA USO DIRECTO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


@ras_commander_required
@handle_ras_exceptions
def quick_boundary_analysis(hdf_file_path: str) -> Dict[str, Any]:
    """
    An√°lisis r√°pido de condiciones de frontera.

    Args:
        hdf_file_path: Ruta al archivo HDF

    Returns:
        Dict con an√°lisis de condiciones de frontera
    """
    analyzer = CommanderFlowAnalyzer(hdf_file_path)
    return analyzer.get_boundary_conditions_analysis()


@ras_commander_required
@handle_ras_exceptions
def quick_fluvial_pluvial_analysis(
    hdf_file_path: str, delta_t: int = 12
) -> Dict[str, Any]:
    """
    An√°lisis r√°pido fluvial-pluvial.

    Args:
        hdf_file_path: Ruta al archivo HDF
        delta_t: Umbral de tiempo en horas

    Returns:
        Dict con an√°lisis fluvial-pluvial
    """
    analyzer = CommanderFlowAnalyzer(hdf_file_path)
    return analyzer.get_fluvial_pluvial_analysis(delta_t)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FUNCI√ìN PRINCIPAL PARA TESTING
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


def main():
    """
    Funci√≥n principal para testing del m√≥dulo commander_flow.
    """
    print("üåä RAS Commander Flow Analyzer - Test Mode")
    print("=" * 60)

    if len(sys.argv) < 2:
        print("Uso: python commander_flow.py <hdf_file_path> [delta_t]")
        return

    hdf_file_path = sys.argv[1]
    delta_t = int(sys.argv[2]) if len(sys.argv) > 2 else 12

    # Test del analizador de flujo
    analyzer = CommanderFlowAnalyzer(hdf_file_path)

    # Test de an√°lisis de condiciones de frontera
    print("Analizando condiciones de frontera...")
    boundary_result = analyzer.get_boundary_conditions_analysis()
    print(f"Condiciones de frontera: {safe_json_serialize(boundary_result)}")

    # Test de an√°lisis fluvial-pluvial
    print(f"\nAnalizando l√≠mites fluvial-pluvial (delta_t={delta_t}h)...")
    fp_result = analyzer.get_fluvial_pluvial_analysis(delta_t)
    print(f"Fluvial-pluvial: {safe_json_serialize(fp_result)}")


if __name__ == "__main__":
    main()
