#!/usr/bin/env python3
"""
üèóÔ∏è RAS Commander Infrastructure Analysis Module
===============================================

M√≥dulo especializado para el an√°lisis de infraestructura hidr√°ulica HEC-RAS usando RAS Commander.
Proporciona funcionalidades avanzadas para an√°lisis de puentes, alcantarillas, tuber√≠as y estaciones de bombeo.

Funcionalidades principales:
- An√°lisis de puentes y alcantarillas
- Procesamiento de redes de tuber√≠as
- An√°lisis de estaciones de bombeo
- Evaluaci√≥n de estructuras hidr√°ulicas
- An√°lisis de compuertas y vertederos

Autor: eFlood2 Technologies
Versi√≥n: 0.1.0
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IMPORTS Y CONFIGURACI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import json
import logging
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import geopandas as gpd
import numpy as np
import pandas as pd

# RAS Commander imports
try:
    from ras_commander import HdfBndry, HdfMesh, HdfPipe, HdfPump, HdfStruc

    RAS_COMMANDER_AVAILABLE = True
except ImportError:
    RAS_COMMANDER_AVAILABLE = False

# Imports locales
from .commander_utils import (
    convert_numpy_types,
    create_result_dict,
    handle_ras_exceptions,
    logger,
    ras_commander_required,
    safe_json_serialize,
    validate_hdf_file,
)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CLASE PRINCIPAL PARA AN√ÅLISIS DE INFRAESTRUCTURA
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


class CommanderInfrastructureAnalyzer:
    """
    üèóÔ∏è Analizador de infraestructura HEC-RAS usando RAS Commander.

    Proporciona funcionalidades avanzadas para el an√°lisis de infraestructura
    hidr√°ulica incluyendo puentes, alcantarillas, tuber√≠as y estaciones de bombeo.
    """

    def __init__(self, hdf_file_path: str):
        """
        Inicializa el analizador de infraestructura.

        Args:
            hdf_file_path: Ruta al archivo HDF de HEC-RAS
        """
        self.hdf_file_path = hdf_file_path
        self.validation_result = validate_hdf_file(hdf_file_path)

        if not self.validation_result["success"]:
            logger.error(
                f"Error validando archivo HDF: {self.validation_result['error']}"
            )

    @ras_commander_required
    @handle_ras_exceptions
    def get_comprehensive_infrastructure_analysis(self) -> Dict[str, Any]:
        """
        Realiza an√°lisis completo de toda la infraestructura del modelo.

        Returns:
            Dict con an√°lisis completo de infraestructura
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            infrastructure_analysis = {
                "structures": self._analyze_structures(),
                "pipe_networks": self._analyze_pipe_networks(),
                "pump_stations": self._analyze_pump_stations(),
                "bridges_culverts": self._analyze_bridges_culverts(),
                "gates_weirs": self._analyze_gates_weirs(),
            }

            # Contar total de elementos de infraestructura
            total_infrastructure = sum(
                analysis.get("count", 0)
                for analysis in infrastructure_analysis.values()
                if isinstance(analysis, dict)
            )

            logger.info(
                f"An√°lisis de infraestructura completado: {total_infrastructure} elementos"
            )

            return create_result_dict(
                success=True,
                data={
                    "total_infrastructure_elements": total_infrastructure,
                    "analysis_timestamp": datetime.now().isoformat(),
                    "infrastructure_by_type": infrastructure_analysis,
                },
                message=f"An√°lisis de {total_infrastructure} elementos de infraestructura completado",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def get_pipe_network_analysis(self) -> Dict[str, Any]:
        """
        Realiza an√°lisis detallado de redes de tuber√≠as.

        Returns:
            Dict con an√°lisis detallado de redes de tuber√≠as
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # Obtener red de tuber√≠as usando RAS Commander
            pipe_network = HdfPipe.get_pipe_network(self.hdf_file_path)

            if pipe_network is None or pipe_network.empty:
                return create_result_dict(
                    success=False,
                    error="No se encontraron redes de tuber√≠as en el modelo",
                )

            # An√°lisis detallado de la red de tuber√≠as
            analysis = {
                "total_pipes": len(pipe_network),
                "columns": list(pipe_network.columns),
                "has_geometry": hasattr(pipe_network, "geometry"),
                "pipe_statistics": {},
                "conduits_analysis": self._analyze_pipe_conduits(),
                "network_connectivity": self._analyze_network_connectivity(
                    pipe_network
                ),
            }

            # Estad√≠sticas de tuber√≠as
            numeric_cols = pipe_network.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats_dict = pipe_network[numeric_cols].describe().to_dict()
                analysis["pipe_statistics"] = convert_numpy_types(stats_dict)

            logger.info(
                f"An√°lisis de red de tuber√≠as completado: {len(pipe_network)} tuber√≠as"
            )

            return create_result_dict(
                success=True,
                data=analysis,
                message=f"An√°lisis de red de tuber√≠as completado: {len(pipe_network)} elementos",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def get_pump_stations_analysis(self) -> Dict[str, Any]:
        """
        Realiza an√°lisis detallado de estaciones de bombeo.

        Returns:
            Dict con an√°lisis detallado de estaciones de bombeo
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # Obtener estaciones de bombeo usando RAS Commander
            pump_stations = HdfPump.get_pump_stations(self.hdf_file_path)

            if pump_stations is None or pump_stations.empty:
                return create_result_dict(
                    success=False,
                    error="No se encontraron estaciones de bombeo en el modelo",
                )

            # An√°lisis detallado de estaciones de bombeo
            analysis = {
                "total_pump_stations": len(pump_stations),
                "columns": list(pump_stations.columns),
                "has_geometry": hasattr(pump_stations, "geometry"),
                "pump_statistics": {},
                "performance_summary": self._get_pump_performance_summary(),
            }

            # Estad√≠sticas de bombas
            numeric_cols = pump_stations.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats_dict = pump_stations[numeric_cols].describe().to_dict()
                analysis["pump_statistics"] = convert_numpy_types(stats_dict)

            logger.info(
                f"An√°lisis de estaciones de bombeo completado: {len(pump_stations)} estaciones"
            )

            return create_result_dict(
                success=True,
                data=analysis,
                message=f"An√°lisis de estaciones de bombeo completado: {len(pump_stations)} elementos",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def export_infrastructure_report(self, output_path: str) -> Dict[str, Any]:
        """
        Exporta un reporte completo de infraestructura.

        Args:
            output_path: Ruta del archivo de reporte

        Returns:
            Dict con resultado de la exportaci√≥n
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # Obtener an√°lisis completo
            infrastructure_analysis = self.get_comprehensive_infrastructure_analysis()

            # Preparar reporte
            report = {
                "report_metadata": {
                    "generated_at": datetime.now().isoformat(),
                    "hdf_file": self.hdf_file_path,
                    "generated_by": "eFlood2 RAS Commander Infrastructure Analyzer",
                    "version": "0.1.0",
                },
                "infrastructure_analysis": infrastructure_analysis.get("data", {}),
                "detailed_analyses": {
                    "pipe_networks": self.get_pipe_network_analysis().get("data", {}),
                    "pump_stations": self.get_pump_stations_analysis().get("data", {}),
                },
            }

            # Exportar reporte
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(report, f, indent=2, ensure_ascii=False)

            logger.info(f"Reporte de infraestructura exportado: {output_path}")

            return create_result_dict(
                success=True,
                data={
                    "report_file": output_path,
                    "file_size_kb": round(os.path.getsize(output_path) / 1024, 2),
                    "sections_included": len(report),
                },
                message=f"Reporte de infraestructura exportado exitosamente: {output_path}",
            )

        except Exception as e:
            raise e

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # M√âTODOS PRIVADOS DE AN√ÅLISIS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _analyze_structures(self) -> Dict[str, Any]:
        """Analiza estructuras generales del modelo."""
        try:
            # Obtener estructuras usando HdfStruc
            # Nota: La implementaci√≥n espec√≠fica depende de los m√©todos disponibles
            return {
                "count": 0,
                "note": "An√°lisis de estructuras generales pendiente de implementaci√≥n espec√≠fica",
            }
        except Exception as e:
            return {"error": f"Error analizando estructuras: {str(e)}"}

    def _analyze_pipe_networks(self) -> Dict[str, Any]:
        """Analiza redes de tuber√≠as b√°sicas."""
        try:
            pipe_network = HdfPipe.get_pipe_network(self.hdf_file_path)

            if pipe_network is None or pipe_network.empty:
                return {"count": 0, "note": "No se encontraron redes de tuber√≠as"}

            return {
                "count": len(pipe_network),
                "columns": list(pipe_network.columns),
                "has_geometry": hasattr(pipe_network, "geometry"),
            }
        except Exception as e:
            return {"error": f"Error analizando redes de tuber√≠as: {str(e)}"}

    def _analyze_pump_stations(self) -> Dict[str, Any]:
        """Analiza estaciones de bombeo b√°sicas."""
        try:
            pump_stations = HdfPump.get_pump_stations(self.hdf_file_path)

            if pump_stations is None or pump_stations.empty:
                return {"count": 0, "note": "No se encontraron estaciones de bombeo"}

            return {
                "count": len(pump_stations),
                "columns": list(pump_stations.columns),
                "has_geometry": hasattr(pump_stations, "geometry"),
            }
        except Exception as e:
            return {"error": f"Error analizando estaciones de bombeo: {str(e)}"}

    def _analyze_bridges_culverts(self) -> Dict[str, Any]:
        """Analiza puentes y alcantarillas."""
        try:
            # Implementar an√°lisis espec√≠fico de puentes y alcantarillas
            return {
                "count": 0,
                "note": "An√°lisis de puentes y alcantarillas pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando puentes y alcantarillas: {str(e)}"}

    def _analyze_gates_weirs(self) -> Dict[str, Any]:
        """Analiza compuertas y vertederos."""
        try:
            # Implementar an√°lisis espec√≠fico de compuertas y vertederos
            return {
                "count": 0,
                "note": "An√°lisis de compuertas y vertederos pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando compuertas y vertederos: {str(e)}"}

    def _analyze_pipe_conduits(self) -> Dict[str, Any]:
        """Analiza conductos de tuber√≠as."""
        try:
            conduits = HdfPipe.get_pipe_conduits(self.hdf_file_path)

            if conduits is None or conduits.empty:
                return {"count": 0, "note": "No se encontraron conductos"}

            return {
                "count": len(conduits),
                "columns": list(conduits.columns),
                "has_geometry": hasattr(conduits, "geometry"),
            }
        except Exception as e:
            return {"error": f"Error analizando conductos: {str(e)}"}

    def _analyze_network_connectivity(
        self, pipe_network: pd.DataFrame
    ) -> Dict[str, Any]:
        """Analiza conectividad de la red de tuber√≠as."""
        try:
            # An√°lisis b√°sico de conectividad
            connectivity_analysis = {
                "total_nodes": 0,
                "total_connections": len(pipe_network),
                "network_density": 0.0,
                "isolated_components": 0,
            }

            # Implementar an√°lisis m√°s detallado seg√∫n la estructura de datos disponible

            return connectivity_analysis
        except Exception as e:
            return {"error": f"Error analizando conectividad: {str(e)}"}

    def _get_pump_performance_summary(self) -> Dict[str, Any]:
        """Obtiene resumen de rendimiento de bombas."""
        try:
            performance_summary = HdfPump.get_pump_station_summary(self.hdf_file_path)

            if performance_summary is None or performance_summary.empty:
                return {"note": "No se encontr√≥ resumen de rendimiento de bombas"}

            return {
                "summary_available": True,
                "columns": list(performance_summary.columns),
                "records": len(performance_summary),
            }
        except Exception as e:
            return {"error": f"Error obteniendo resumen de rendimiento: {str(e)}"}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FUNCIONES DE UTILIDAD PARA USO DIRECTO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


@ras_commander_required
@handle_ras_exceptions
def quick_infrastructure_analysis(hdf_file_path: str) -> Dict[str, Any]:
    """
    An√°lisis r√°pido de infraestructura.

    Args:
        hdf_file_path: Ruta al archivo HDF

    Returns:
        Dict con an√°lisis de infraestructura
    """
    analyzer = CommanderInfrastructureAnalyzer(hdf_file_path)
    return analyzer.get_comprehensive_infrastructure_analysis()


@ras_commander_required
@handle_ras_exceptions
def quick_pipe_network_analysis(hdf_file_path: str) -> Dict[str, Any]:
    """
    An√°lisis r√°pido de redes de tuber√≠as.

    Args:
        hdf_file_path: Ruta al archivo HDF

    Returns:
        Dict con an√°lisis de redes de tuber√≠as
    """
    analyzer = CommanderInfrastructureAnalyzer(hdf_file_path)
    return analyzer.get_pipe_network_analysis()


@ras_commander_required
@handle_ras_exceptions
def quick_pump_stations_analysis(hdf_file_path: str) -> Dict[str, Any]:
    """
    An√°lisis r√°pido de estaciones de bombeo.

    Args:
        hdf_file_path: Ruta al archivo HDF

    Returns:
        Dict con an√°lisis de estaciones de bombeo
    """
    analyzer = CommanderInfrastructureAnalyzer(hdf_file_path)
    return analyzer.get_pump_stations_analysis()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FUNCI√ìN PRINCIPAL PARA TESTING
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


def main():
    """
    Funci√≥n principal para testing del m√≥dulo commander_infrastructure.
    """
    print("üèóÔ∏è RAS Commander Infrastructure Analyzer - Test Mode")
    print("=" * 60)

    if len(sys.argv) < 2:
        print("Uso: python commander_infrastructure.py <hdf_file_path>")
        return

    hdf_file_path = sys.argv[1]

    # Test del analizador de infraestructura
    analyzer = CommanderInfrastructureAnalyzer(hdf_file_path)

    # Test de an√°lisis completo de infraestructura
    print("Analizando infraestructura completa...")
    infra_result = analyzer.get_comprehensive_infrastructure_analysis()
    print(f"Infraestructura: {safe_json_serialize(infra_result)}")

    # Test de an√°lisis de redes de tuber√≠as
    print("\nAnalizando redes de tuber√≠as...")
    pipe_result = analyzer.get_pipe_network_analysis()
    print(f"Redes de tuber√≠as: {safe_json_serialize(pipe_result)}")

    # Test de an√°lisis de estaciones de bombeo
    print("\nAnalizando estaciones de bombeo...")
    pump_result = analyzer.get_pump_stations_analysis()
    print(f"Estaciones de bombeo: {safe_json_serialize(pump_result)}")


if __name__ == "__main__":
    main()
