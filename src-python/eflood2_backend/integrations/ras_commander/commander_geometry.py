#!/usr/bin/env python3
"""
üìê RAS Commander Geometry Processing Module
===========================================

M√≥dulo especializado para el procesamiento de geometr√≠a y mallas HEC-RAS usando RAS Commander.
Proporciona funcionalidades avanzadas para an√°lisis de geometr√≠a, mallas 2D y elementos estructurales.

Funcionalidades principales:
- An√°lisis de mallas 2D (mesh areas)
- Procesamiento de geometr√≠a de canales
- Extracci√≥n de breaklines y elementos estructurales
- An√°lisis de secciones transversales
- Procesamiento de datos de elevaci√≥n

Autor: eFlood2 Technologies
Versi√≥n: 0.1.0
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IMPORTS Y CONFIGURACI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import json
import logging
import os
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import geopandas as gpd
import numpy as np
import pandas as pd

# RAS Commander imports
try:
    from ras_commander import (
        HdfBndry,
        HdfMesh,
        HdfResultsMesh,
        HdfStruc,
        RasGeo,
        RasPlan,
    )

    RAS_COMMANDER_AVAILABLE = True
except ImportError:
    RAS_COMMANDER_AVAILABLE = False

# Imports locales
from .commander_utils import (
    convert_numpy_types,
    create_result_dict,
    handle_ras_exceptions,
    logger,
    ras_commander_required,
    safe_json_serialize,
    validate_hdf_file,
)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CLASE PRINCIPAL PARA PROCESAMIENTO DE GEOMETR√çA
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


class CommanderGeometryProcessor:
    """
    üìê Procesador de geometr√≠a HEC-RAS usando RAS Commander.

    Proporciona funcionalidades avanzadas para el an√°lisis y procesamiento
    de geometr√≠a, mallas 2D y elementos estructurales en modelos HEC-RAS.
    """

    def __init__(self, hdf_file_path: str):
        """
        Inicializa el procesador de geometr√≠a.

        Args:
            hdf_file_path: Ruta al archivo HDF de HEC-RAS
        """
        self.hdf_file_path = hdf_file_path
        self.validation_result = validate_hdf_file(hdf_file_path)

        if not self.validation_result["success"]:
            logger.error(
                f"Error validando archivo HDF: {self.validation_result['error']}"
            )

    @ras_commander_required
    @handle_ras_exceptions
    def get_mesh_areas_info(self) -> Dict[str, Any]:
        """
        Obtiene informaci√≥n detallada de todas las √°reas de malla 2D.

        Returns:
            Dict con informaci√≥n completa de las mallas 2D
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # Obtener nombres de √°reas de malla
            mesh_names = HdfMesh.get_mesh_area_names(self.hdf_file_path)

            if not mesh_names:
                return create_result_dict(
                    success=False,
                    error="No se encontraron √°reas de malla 2D en el archivo HDF",
                )

            mesh_info = {
                "total_mesh_areas": len(mesh_names),
                "mesh_names": mesh_names,
                "mesh_details": {},
            }

            # Obtener detalles de cada malla
            for mesh_name in mesh_names:
                try:
                    mesh_details = self._get_single_mesh_details(mesh_name)
                    mesh_info["mesh_details"][mesh_name] = mesh_details
                except Exception as e:
                    logger.warning(f"Error procesando malla {mesh_name}: {e}")
                    mesh_info["mesh_details"][mesh_name] = {
                        "error": f"Error procesando malla: {str(e)}"
                    }

            logger.info(
                f"Informaci√≥n de mallas obtenida: {len(mesh_names)} √°reas procesadas"
            )

            return create_result_dict(
                success=True,
                data=mesh_info,
                message=f"Informaci√≥n de {len(mesh_names)} √°reas de malla obtenida exitosamente",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def get_breaklines_analysis(self) -> Dict[str, Any]:
        """
        Realiza an√°lisis completo de breaklines del modelo.

        Returns:
            Dict con an√°lisis detallado de breaklines
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # Obtener breaklines usando RAS Commander
            breaklines_gdf = HdfBndry.get_breaklines(self.hdf_file_path)

            if breaklines_gdf is None or breaklines_gdf.empty:
                return create_result_dict(
                    success=False,
                    error="No se encontraron breaklines en el archivo HDF",
                )

            # An√°lisis de breaklines
            analysis = {
                "total_breaklines": len(breaklines_gdf),
                "columns": list(breaklines_gdf.columns),
                "has_geometry": hasattr(breaklines_gdf, "geometry"),
                "statistics": {},
                "spatial_info": {},
            }

            # Estad√≠sticas de columnas num√©ricas
            numeric_cols = breaklines_gdf.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                stats_dict = breaklines_gdf[numeric_cols].describe().to_dict()
                analysis["statistics"] = convert_numpy_types(stats_dict)

            # Informaci√≥n espacial si hay geometr√≠a
            if (
                hasattr(breaklines_gdf, "geometry")
                and breaklines_gdf.geometry is not None
            ):
                bounds = breaklines_gdf.total_bounds
                analysis["spatial_info"] = {
                    "bounds": {
                        "minx": float(bounds[0]),
                        "miny": float(bounds[1]),
                        "maxx": float(bounds[2]),
                        "maxy": float(bounds[3]),
                    },
                    "crs": str(breaklines_gdf.crs) if breaklines_gdf.crs else None,
                    "geometry_types": breaklines_gdf.geometry.geom_type.value_counts().to_dict(),
                }

            logger.info(
                f"An√°lisis de breaklines completado: {len(breaklines_gdf)} elementos"
            )

            return create_result_dict(
                success=True,
                data=analysis,
                message=f"An√°lisis de {len(breaklines_gdf)} breaklines completado exitosamente",
            )

        except Exception as e:
            raise e

    @ras_commander_required
    @handle_ras_exceptions
    def get_structures_analysis(self) -> Dict[str, Any]:
        """
        Realiza an√°lisis completo de estructuras del modelo.

        Returns:
            Dict con an√°lisis detallado de estructuras
        """
        if not self.validation_result["success"]:
            return self.validation_result

        try:
            # Obtener informaci√≥n de estructuras usando RAS Commander
            structures_info = {
                "bridges": self._analyze_bridges(),
                "culverts": self._analyze_culverts(),
                "gates": self._analyze_gates(),
                "weirs": self._analyze_weirs(),
            }

            # Contar total de estructuras
            total_structures = sum(
                info.get("count", 0)
                for info in structures_info.values()
                if isinstance(info, dict)
            )

            logger.info(
                f"An√°lisis de estructuras completado: {total_structures} elementos"
            )

            return create_result_dict(
                success=True,
                data={
                    "total_structures": total_structures,
                    "structures_by_type": structures_info,
                },
                message=f"An√°lisis de {total_structures} estructuras completado exitosamente",
            )

        except Exception as e:
            raise e

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # M√âTODOS PRIVADOS DE UTILIDAD
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _get_single_mesh_details(self, mesh_name: str) -> Dict[str, Any]:
        """
        Obtiene detalles de una malla espec√≠fica.

        Args:
            mesh_name: Nombre de la malla

        Returns:
            Dict con detalles de la malla
        """
        details = {
            "mesh_name": mesh_name,
            "has_data": False,
            "cell_count": 0,
            "face_count": 0,
        }

        try:
            # Intentar obtener informaci√≥n b√°sica de la malla
            # Nota: Los m√©todos espec√≠ficos dependen de la API de RAS Commander
            # Aqu√≠ se implementar√≠a la l√≥gica espec√≠fica para cada tipo de dato

            details["has_data"] = True
            logger.debug(f"Detalles obtenidos para malla: {mesh_name}")

        except Exception as e:
            logger.warning(f"Error obteniendo detalles de malla {mesh_name}: {e}")
            details["error"] = str(e)

        return details

    def _analyze_bridges(self) -> Dict[str, Any]:
        """Analiza puentes en el modelo."""
        try:
            # Implementar an√°lisis de puentes usando HdfStruc
            return {
                "count": 0,
                "note": "An√°lisis de puentes pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando puentes: {str(e)}"}

    def _analyze_culverts(self) -> Dict[str, Any]:
        """Analiza alcantarillas en el modelo."""
        try:
            # Implementar an√°lisis de alcantarillas usando HdfStruc
            return {
                "count": 0,
                "note": "An√°lisis de alcantarillas pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando alcantarillas: {str(e)}"}

    def _analyze_gates(self) -> Dict[str, Any]:
        """Analiza compuertas en el modelo."""
        try:
            # Implementar an√°lisis de compuertas usando HdfStruc
            return {
                "count": 0,
                "note": "An√°lisis de compuertas pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando compuertas: {str(e)}"}

    def _analyze_weirs(self) -> Dict[str, Any]:
        """Analiza vertederos en el modelo."""
        try:
            # Implementar an√°lisis de vertederos usando HdfStruc
            return {
                "count": 0,
                "note": "An√°lisis de vertederos pendiente de implementaci√≥n",
            }
        except Exception as e:
            return {"error": f"Error analizando vertederos: {str(e)}"}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FUNCIONES DE UTILIDAD PARA USO DIRECTO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


@ras_commander_required
@handle_ras_exceptions
def quick_mesh_analysis(hdf_file_path: str) -> Dict[str, Any]:
    """
    An√°lisis r√°pido de mallas 2D.

    Args:
        hdf_file_path: Ruta al archivo HDF

    Returns:
        Dict con an√°lisis de mallas
    """
    processor = CommanderGeometryProcessor(hdf_file_path)
    return processor.get_mesh_areas_info()


@ras_commander_required
@handle_ras_exceptions
def quick_breaklines_analysis(hdf_file_path: str) -> Dict[str, Any]:
    """
    An√°lisis r√°pido de breaklines.

    Args:
        hdf_file_path: Ruta al archivo HDF

    Returns:
        Dict con an√°lisis de breaklines
    """
    processor = CommanderGeometryProcessor(hdf_file_path)
    return processor.get_breaklines_analysis()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# FUNCI√ìN PRINCIPAL PARA TESTING
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


def main():
    """
    Funci√≥n principal para testing del m√≥dulo commander_geometry.
    """
    print("üìê RAS Commander Geometry Processor - Test Mode")
    print("=" * 60)

    if len(sys.argv) < 2:
        print("Uso: python commander_geometry.py <hdf_file_path>")
        return

    hdf_file_path = sys.argv[1]

    # Test del procesador de geometr√≠a
    processor = CommanderGeometryProcessor(hdf_file_path)

    # Test de an√°lisis de mallas
    print("Analizando mallas 2D...")
    mesh_result = processor.get_mesh_areas_info()
    print(f"Resultado mallas: {safe_json_serialize(mesh_result)}")

    # Test de an√°lisis de breaklines
    print("\nAnalizando breaklines...")
    breaklines_result = processor.get_breaklines_analysis()
    print(f"Resultado breaklines: {safe_json_serialize(breaklines_result)}")


if __name__ == "__main__":
    main()
